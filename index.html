<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è´¨æŠ¼ & åˆ†çº¢ (BSC) - é”™è¯¯ä¿®å¤ç»ˆæç‰ˆ</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 128 128%22><text x=%220%22 y=%2290%22 font-size=%2290%22>ğŸ¤‘</text></svg>" type="image/svg+xml">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background-color: #1a1a2e; color: #ffffff; min-height: 100vh; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; }
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; padding-bottom: 10px; border-bottom: 1px solid #333; }
        .logo { font-size: 20px; font-weight: bold; color: #ffffff; }
        .connect-btn { background-color: #0066ff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: 500; transition: background-color 0.3s; }
        .connect-btn:disabled { background-color: #666; cursor: not-allowed; }
        .connect-btn:hover:not(:disabled) { background-color: #0052cc; }
        .section { background-color: #16213e; border-radius: 10px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .section-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: #e0e0e0; }
        .info-line { margin-bottom: 10px; color: #b0b0b0; }
        .btn { width: 100%; padding: 12px; border: none; border-radius: 5px; cursor: pointer; font-weight: 500; font-size: 16px; margin-top: 10px; transition: background-color 0.3s; }
        .btn-primary { background-color: #6441a5; color: white; }
        .btn-primary:hover { background-color: #533894; }
        .btn-danger { background-color: #e74c3c; color: white; }
        .btn-danger:hover { background-color: #c0392b; }
        .btn-outline { background-color: transparent; color: #b0b0b0; border: 1px solid #333; }
        .btn-outline:hover { background-color: #2d3436; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; color: #b0b0b0; font-size: 14px; }
        .input-group input { width: 100%; padding: 12px; background-color: #0f3460; border: 1px solid #333; border-radius: 5px; color: white; font-size: 16px; }
        .input-group input::placeholder { color: #666; }
        .stake-item { background-color: #0f3460; padding: 15px; border-radius: 5px; margin-bottom: 10px; }
        .stake-item .stake-info { font-size: 14px; margin-bottom: 5px; color: #b0b0b0; }
        .status { margin-top: 15px; padding: 10px; border-radius: 5px; font-size: 14px; font-weight: 500; display: none; }
        .status.success { background-color: #27ae60; color: white; display: block; }
        .status.error { background-color: #c0392b; color: white; display: block; }
        .status.info { background-color: #3498db; color: white; display: block; }
        .hidden { display: none; }
        .network-alert { background-color: #ff9800; color: white; padding: 10px; border-radius: 5px; margin-bottom: 15px; text-align: center; }
        .note { font-size: 13px; color: #888; margin-top: 5px; font-style: italic; }
        .warning { background-color: #e67e22; color: white; padding: 8px; border-radius: 3px; margin-top: 5px; font-size: 13px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">è´¨æŠ¼ & åˆ†çº¢ (BSC) - ä¿®å¤ç‰ˆ</div>
            <button id="connect-btn" class="connect-btn">è¿æ¥ MetaMask</button>
        </header>

        <div id="app-content" class="hidden">
            <!-- ç½‘ç»œè­¦å‘Š -->
            <div id="network-alert" class="network-alert hidden">
                âš ï¸ è­¦å‘Šï¼šå½“å‰ç½‘ç»œä¸æ˜¯ BSC ä¸»ç½‘ï¼Œè¯·åˆ‡æ¢åˆ° BSC ä¸»ç½‘ï¼ˆChain ID: 56ï¼‰åé‡è¯•ï¼
            </div>

            <!-- è´¦æˆ·ä¿¡æ¯ -->
            <div class="section">
                <div class="section-title">è´¦æˆ·ä¿¡æ¯</div>
                <div class="info-line">å·²è¿æ¥è´¦æˆ·: <span id="connected-account">-</span></div>
                <div class="info-line">å½“å‰ç½‘ç»œ: <span id="current-network">-</span></div>
                <div class="info-line">å¯é¢†å–åˆ†çº¢: <span id="pending-rewards">-</span> BNB</div>
                <div class="info-line">MEME ä»£å¸åœ°å€: <span id="meme-token-address">-</span></div>
                <div class="info-line">åˆçº¦çŠ¶æ€: <span id="contract-status">-</span></div>
                <div class="warning hidden" id="contract-paused-warning">
                    âš ï¸ åˆçº¦å·²æš‚åœï¼æ‰€æœ‰æ“ä½œæ— æ³•æ‰§è¡Œï¼Œè¯·è”ç³»ç®¡ç†å‘˜ã€‚
                </div>
            </div>

            <!-- è´¨æŠ¼åˆ—è¡¨ -->
            <div class="section">
                <div class="section-title">æˆ‘çš„è´¨æŠ¼æ¡ç›®</div>
                <button id="refresh-stakes" class="btn btn-outline">åˆ·æ–°è´¨æŠ¼åˆ—è¡¨</button>
                <div id="stakes-list" style="margin-top: 15px;">
                    <div style="text-align: center; color: #666;">æš‚æ— è´¨æŠ¼è®°å½•</div>
                </div>
            </div>

            <!-- æ ¸å¿ƒæ“ä½œåŒº -->
            <div class="section">
                <div class="section-title">æ ¸å¿ƒæ“ä½œ</div>

                <!-- é¢†å–åˆ†çº¢ -->
                <div style="margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid #2d3436;">
                    <div class="section-title" style="font-size: 16px; margin-bottom: 10px;">1. é¢†å–åˆ†çº¢</div>
                    <button id="claim-rewards" class="btn btn-primary">ç«‹å³é¢†å–åˆ†çº¢</button>
                    <div class="note">æç¤ºï¼šé¢†å–åä¼šè‡ªåŠ¨åˆ·æ–°åˆ†çº¢é‡‘é¢</div>
                    <div class="note">å¦‚æœå¤±è´¥ï¼šå¯èƒ½æ˜¯åˆçº¦æ— è¶³å¤ŸBNBåˆ†çº¢æˆ–åˆçº¦æš‚åœ</div>
                </div>

                <!-- è´¨æŠ¼ä»£å¸ -->
                <div style="margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid #2d3436;">
                    <div class="section-title" style="font-size: 16px; margin-bottom: 10px;">2. è´¨æŠ¼ MEME ä»£å¸</div>
                    <div class="input-group">
                        <label for="stake-amount">è´¨æŠ¼æ•°é‡ï¼ˆMEMEï¼‰</label>
                        <input type="text" id="stake-amount" placeholder="ä¾‹å¦‚ï¼š100ï¼ˆæ”¯æŒå°æ•°ï¼Œä¸è¦è¾“å…¥è¿‡å¤§æ•°å€¼ï¼‰">
                    </div>
                    <button id="approve-token" class="btn btn-outline">ç¬¬ä¸€æ­¥ï¼šæˆæƒä»£å¸ï¼ˆä»…é¦–æ¬¡éœ€æ“ä½œï¼‰</button>
                    <button id="stake-token" class="btn btn-primary">ç¬¬äºŒæ­¥ï¼šç¡®è®¤è´¨æŠ¼</button>
                    <div class="note">æç¤ºï¼šéœ€å…ˆæˆæƒå†è´¨æŠ¼ï¼Œè´¨æŠ¼åå°†é”å®šè‡³è§£é”åŒºå—</div>
                </div>

                <!-- å–æ¶ˆè´¨æŠ¼ -->
                <div>
                    <div class="section-title" style="font-size: 16px; margin-bottom: 10px;">3. å–æ¶ˆè´¨æŠ¼</div>
                    <div class="input-group">
                        <label for="unstake-index">è´¨æŠ¼ç´¢å¼•ï¼ˆä»è´¨æŠ¼åˆ—è¡¨æŸ¥çœ‹ï¼‰</label>
                        <input type="number" id="unstake-index" placeholder="ä¾‹å¦‚ï¼š0ï¼ˆæ•´æ•°ï¼‰" min="0">
                    </div>
                    <button id="unstake-token" class="btn btn-danger">ç¡®è®¤å–æ¶ˆè´¨æŠ¼</button>
                    <div class="note">æç¤ºï¼šæå‰å–æ¶ˆå¯èƒ½äº§ç”Ÿæƒ©ç½šï¼Œä»¥åˆçº¦è§„åˆ™ä¸ºå‡†</div>
                </div>
            </div>

            <!-- çŠ¶æ€æç¤ºåŒº -->
            <div id="status" class="status"></div>
        </div>

        <!-- æœªè¿æ¥é’±åŒ…æ—¶çš„æ¬¢è¿é¡µ -->
        <div id="welcome-content">
            <div class="section" style="text-align: center; padding: 50px 20px;">
                <div class="section-title" style="font-size: 24px; margin-bottom: 20px;">æ¬¢è¿ä½¿ç”¨è´¨æŠ¼ & åˆ†çº¢ DApp</div>
                <p style="margin-bottom: 30px; color: #b0b0b0; line-height: 1.6;">
                    è¯·è¿æ¥æ‚¨çš„ MetaMask é’±åŒ…<br>
                    å¹¶åˆ‡æ¢è‡³ <strong>BSC ä¸»ç½‘ï¼ˆChain ID: 56ï¼‰</strong> å¼€å§‹ä½¿ç”¨
                </p>
                <button id="welcome-connect-btn" class="btn btn-primary">è¿æ¥ MetaMask</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== åŸºç¡€é…ç½®+æ—¥å¿—å¸¸é‡ ====================
        const LOG_PREFIX = '[DAppä¿®å¤ç‰ˆæ—¥å¿—]:';
        const CONTRACT_ADDRESS = '0xCb5c82879A56006d6eEF2d03391E48ff774919A2'; // è¯·å†æ¬¡æ ¸å¯¹ï¼
        const BSC_MAINNET_CHAIN_ID = '0x38'; // 56çš„åå…­è¿›åˆ¶
        const DEFAULT_MEME_TOKEN_ADDRESS = ''; // æ‰‹åŠ¨å¡«å†™ä»£å¸åœ°å€ï¼ˆæ ¼å¼ï¼š0x...ï¼‰
        let currentAccount = null;
        let currentChainId = null;
        let memeTokenAddress = DEFAULT_MEME_TOKEN_ADDRESS;
        let isContractPaused = false; // åˆçº¦æ˜¯å¦æš‚åœ

        // ==================== å…³é”®ä¿®å¤1ï¼šè¡¥å…… ERC20 ä»£å¸åˆçº¦ ABIï¼ˆæˆæƒç”¨ï¼‰====================
        const ERC20_ABI = [
            {
                "constant": false,
                "inputs": [{"name": "_spender", "type": "address"}, {"name": "_value", "type": "uint256"}],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "payable": false,
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        // è´¨æŠ¼åˆçº¦ABIï¼ˆå®Œæ•´ï¼‰
        const STAKING_ABI = [{"inputs":[{"internalType":"address","name":"_memeToken","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"EnforcedPause","type":"error"},{"inputs":[],"name":"ExpectedPause","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"DividendDistributed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"admin","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdrawBNB","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"admin","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdrawMEME","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newBlocks","type":"uint256"}],"name":"LockBlocksUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"oldToken","type":"address"},{"indexed":false,"internalType":"address","name":"newToken","type":"address"}],"name":"MemeTokenUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newAmount","type":"uint256"}],"name":"MinLockAmountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"RewardClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Staked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"penalty","type":"uint256"}],"name":"Unstaked","type":"event"},{"inputs":[],"name":"BURN_ADDRESS","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DISTRIBUTION_THRESHOLD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PENALTY_RATE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"disableStaking","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"dividendPerToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"emergencyWithdrawBNB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"emergencyWithdrawMEME","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableStaking","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getPendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getUserStake","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"startBlock","type":"uint256"},{"internalType":"uint256","name":"unlockBlock","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getUserStakeCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lockBlocks","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"memeToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minLockAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingBNB","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_blocks","type":"uint256"}],"name":"setLockBlocks","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newMemeToken","type":"address"}],"name":"setMemeToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"setMinLockAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"stake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"unstake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"userStakes","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"startBlock","type":"uint256"},{"internalType":"uint256","name":"dividendPerTokenAtStake","type":"uint256"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}];

        // ==================== å·¥å…·å‡½æ•°ï¼ˆå…³é”®ä¿®å¤2+3ï¼‰ ====================
        console.log(LOG_PREFIX, 'å¼€å§‹åˆå§‹åŒ–å·¥å…·å‡½æ•°');

        // å…³é”®ä¿®å¤2ï¼šä¿®å¤ parseEther ç§‘å­¦è®¡æ•°æ³•é—®é¢˜ï¼ˆBigIntä¸æ”¯æŒ1e+23ï¼‰
        function parseEther(etherStr) {
            console.log(LOG_PREFIX, 'parseEtherè°ƒç”¨ï¼Œè¾“å…¥:', etherStr);
            const ether = parseFloat(etherStr);
            if (isNaN(ether)) {
                console.log(LOG_PREFIX, 'parseEtherç»“æœ: 0');
                return '0';
            }
            // é¿å…ç§‘å­¦è®¡æ•°æ³•ï¼šç”¨æ•´æ•°å­—ç¬¦ä¸²è¡¨ç¤ºï¼ˆether * 1e18 è½¬æ¢ä¸ºæ•´æ•°ï¼‰
            const wei = Math.floor(ether * 1e18);
            const result = wei.toString();
            console.log(LOG_PREFIX, 'parseEtherç»“æœ:', result);
            return result;
        }

        function formatEther(weiStr) {
            console.log(LOG_PREFIX, 'formatEtherè°ƒç”¨ï¼Œè¾“å…¥:', weiStr);
            const wei = BigInt(weiStr || '0');
            const result = (wei / BigInt(1e18)).toString();
            console.log(LOG_PREFIX, 'formatEtherç»“æœ:', result);
            return result;
        }

        // ç”Ÿæˆå‡½æ•°ç­¾åå“ˆå¸Œ
        async function getFunctionSignatureHash(functionName, params) {
            console.log(LOG_PREFIX, 'getFunctionSignatureHashè°ƒç”¨ï¼Œå‡½æ•°:', functionName, 'å‚æ•°ç±»å‹:', params);
            const funcStr = `${functionName}(${params.join(',')})`;
            const encoder = new TextEncoder();
            const data = encoder.encode(funcStr);
            const hash = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hash));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            const result = hashHex.substring(0, 8);
            console.log(LOG_PREFIX, 'getFunctionSignatureHashç»“æœ:', result);
            return result;
        }

        // ç¼–ç å‚æ•°
        function encodeAddress(address) {
            console.log(LOG_PREFIX, 'encodeAddressè°ƒç”¨ï¼Œè¾“å…¥:', address);
            const result = address.replace('0x', '').padStart(64, '0');
            console.log(LOG_PREFIX, 'encodeAddressç»“æœ:', result);
            return result;
        }

        function encodeUint256(value) {
            console.log(LOG_PREFIX, 'encodeUint256è°ƒç”¨ï¼Œè¾“å…¥:', value);
            // å…³é”®ä¿®å¤3ï¼šç¡®ä¿è¾“å…¥æ˜¯æ•´æ•°å­—ç¬¦ä¸²ï¼Œé¿å…BigIntè½¬æ¢å¤±è´¥
            const intValue = BigInt(value);
            const result = intValue.toString(16).padStart(64, '0');
            console.log(LOG_PREFIX, 'encodeUint256ç»“æœ:', result);
            return result;
        }

        async function encodeParams(functionAbi, params) {
            console.log(LOG_PREFIX, 'encodeParamsè°ƒç”¨ï¼ŒABI:', functionAbi, 'å‚æ•°:', params);
            let data = '';
            for (let i = 0; i < functionAbi.inputs.length; i++) {
                const input = functionAbi.inputs[i];
                const param = params[i];
                switch (input.type) {
                    case 'address': data += encodeAddress(param); break;
                    case 'uint256': data += encodeUint256(param); break;
                    default: throw new Error(`ä¸æ”¯æŒçš„å‚æ•°ç±»å‹: ${input.type}`);
                }
            }
            console.log(LOG_PREFIX, 'encodeParamsç»“æœ:', data);
            return data;
        }

        // å…³é”®ä¿®å¤4ï¼šæ”¯æŒé€‰æ‹©ABIï¼ˆè´¨æŠ¼åˆçº¦/ERC20ä»£å¸åˆçº¦ï¼‰
        async function encodeFunctionCall(functionName, params, abiType = 'staking') {
            console.log(LOG_PREFIX, 'encodeFunctionCallè°ƒç”¨ï¼Œå‡½æ•°:', functionName, 'å‚æ•°:', params, 'ABIç±»å‹:', abiType);
            // é€‰æ‹©å¯¹åº”çš„ABI
            const targetAbi = abiType === 'erc20' ? ERC20_ABI : STAKING_ABI;
            const funcAbi = targetAbi.find(f => f.name === functionName && f.type === 'function');
            
            if (!funcAbi) throw new Error(`å‡½æ•° ${functionName} ä¸å­˜åœ¨ï¼ˆABIç±»å‹: ${abiType}ï¼‰`);
            
            const paramTypes = funcAbi.inputs.map(input => input.type);
            const sigHash = await getFunctionSignatureHash(functionName, paramTypes);
            const paramData = await encodeParams(funcAbi, params);
            const result = `0x${sigHash}${paramData}`;
            console.log(LOG_PREFIX, 'encodeFunctionCallç»“æœ:', result);
            return result;
        }

        // ==================== DOMå…ƒç´ +äº‹ä»¶ç»‘å®š ====================
        console.log(LOG_PREFIX, 'å¼€å§‹è·å–DOMå…ƒç´ ');
        const domElements = {
            connectBtn: document.getElementById('connect-btn'),
            welcomeConnectBtn: document.getElementById('welcome-connect-btn'),
            appContent: document.getElementById('app-content'),
            welcomeContent: document.getElementById('welcome-content'),
            networkAlert: document.getElementById('network-alert'),
            connectedAccountEl: document.getElementById('connected-account'),
            currentNetworkEl: document.getElementById('current-network'),
            pendingRewardsEl: document.getElementById('pending-rewards'),
            memeTokenAddressEl: document.getElementById('meme-token-address'),
            contractStatusEl: document.getElementById('contract-status'),
            contractPausedWarning: document.getElementById('contract-paused-warning'),
            refreshStakesBtn: document.getElementById('refresh-stakes'),
            stakesListEl: document.getElementById('stakes-list'),
            claimRewardsBtn: document.getElementById('claim-rewards'),
            stakeAmountInput: document.getElementById('stake-amount'),
            approveTokenBtn: document.getElementById('approve-token'),
            stakeTokenBtn: document.getElementById('stake-token'),
            unstakeIndexInput: document.getElementById('unstake-index'),
            unstakeTokenBtn: document.getElementById('unstake-token'),
            statusEl: document.getElementById('status')
        };

        // éªŒè¯DOMå…ƒç´ 
        Object.entries(domElements).forEach(([key, el]) => {
            console.log(LOG_PREFIX, `DOMå…ƒç´  ${key} å­˜åœ¨ï¼Ÿ`, !!el);
            if (!el) console.warn(LOG_PREFIX, `è­¦å‘Šï¼šDOMå…ƒç´  ${key} æœªæ‰¾åˆ°`);
        });

        // ç»‘å®šæ‰€æœ‰äº‹ä»¶
        console.log(LOG_PREFIX, 'å¼€å§‹ç»‘å®šäº‹ä»¶');
        if (domElements.connectBtn) domElements.connectBtn.addEventListener('click', connectWallet);
        if (domElements.welcomeConnectBtn) domElements.welcomeConnectBtn.addEventListener('click', connectWallet);
        if (domElements.refreshStakesBtn) domElements.refreshStakesBtn.addEventListener('click', refreshStakes);
        if (domElements.claimRewardsBtn) domElements.claimRewardsBtn.addEventListener('click', claimRewards);
        if (domElements.approveTokenBtn) domElements.approveTokenBtn.addEventListener('click', approveToken);
        if (domElements.stakeTokenBtn) domElements.stakeTokenBtn.addEventListener('click', stakeToken);
        if (domElements.unstakeTokenBtn) domElements.unstakeTokenBtn.addEventListener('click', unstakeToken);
        console.log(LOG_PREFIX, 'äº‹ä»¶ç»‘å®šå®Œæˆ');

        // ç›‘å¬ç½‘ç»œå˜åŒ–
        if (window.ethereum) {
            window.ethereum.on('chainChanged', (chainId) => {
                console.log(LOG_PREFIX, 'ç½‘ç»œåˆ‡æ¢äº‹ä»¶è§¦å‘ï¼Œæ–°chainId:', chainId);
                currentChainId = chainId;
                checkNetwork();
                updateNetworkDisplay();
                if (currentAccount) checkContractStatus(); // ç½‘ç»œåˆ‡æ¢åé‡æ–°æ£€æŸ¥åˆçº¦çŠ¶æ€
            });
            console.log(LOG_PREFIX, 'ç½‘ç»œå˜åŒ–ç›‘å¬ç»‘å®šæˆåŠŸ');
        }

        console.log(LOG_PREFIX, 'åˆå§‹åŒ–å®Œæˆï¼Œç­‰å¾…ç”¨æˆ·æ“ä½œ');

        // ==================== æ ¸å¿ƒé€»è¾‘ ====================
        // è¿æ¥é’±åŒ…
        async function connectWallet() {
            console.log(LOG_PREFIX, '===== å¼€å§‹æ‰§è¡Œè¿æ¥é’±åŒ…é€»è¾‘ =====');
            const { connectBtn, welcomeConnectBtn, statusEl } = domElements;

            try {
                // ç¦ç”¨æŒ‰é’®
                if (connectBtn) { connectBtn.disabled = true; connectBtn.textContent = 'è¿æ¥ä¸­...'; }
                if (welcomeConnectBtn) { welcomeConnectBtn.disabled = true; welcomeConnectBtn.textContent = 'è¿æ¥ä¸­...'; }
                if (statusEl) { statusEl.textContent = 'æ­£åœ¨è¿æ¥MetaMask...'; statusEl.className = 'status info'; }
                console.log(LOG_PREFIX, 'å·²ç¦ç”¨è¿æ¥æŒ‰é’®ï¼Œæ˜¾ç¤ºè¿æ¥ä¸­çŠ¶æ€');

                // æ£€æµ‹MetaMask
                if (!window.ethereum) {
                    throw new Error('æœªæ£€æµ‹åˆ°MetaMaskï¼Œè¯·å®‰è£…åé‡è¯•');
                }
                console.log(LOG_PREFIX, 'æ£€æµ‹åˆ°MetaMaskï¼Œwindow.ethereumå­˜åœ¨');

                // è¯·æ±‚æˆæƒ
                console.log(LOG_PREFIX, 'å‘èµ·è´¦æˆ·æˆæƒè¯·æ±‚');
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                console.log(LOG_PREFIX, 'æˆæƒè¯·æ±‚è¿”å›:', accounts);

                if (!accounts || accounts.length === 0) throw new Error('ç”¨æˆ·æ‹’ç»äº†æˆæƒ');
                currentAccount = accounts[0];
                console.log(LOG_PREFIX, 'è·å–åˆ°è´¦æˆ·:', currentAccount);

                // è·å–ç½‘ç»œ
                console.log(LOG_PREFIX, 'å‘èµ·ç½‘ç»œæŸ¥è¯¢è¯·æ±‚');
                currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
                console.log(LOG_PREFIX, 'è·å–åˆ°ç½‘ç»œchainId:', currentChainId);

                // æ£€æŸ¥ç½‘ç»œ
                const isSupported = checkNetwork();
                console.log(LOG_PREFIX, 'ç½‘ç»œæ˜¯å¦æ”¯æŒ:', isSupported);

                // è·å–ä»£å¸åœ°å€
                if (!memeTokenAddress) {
                    console.log(LOG_PREFIX, 'å¼€å§‹è·å–MEMEä»£å¸åœ°å€ï¼ˆåˆçº¦è°ƒç”¨ï¼‰');
                    await fetchMemeTokenAddress();
                } else {
                    console.log(LOG_PREFIX, 'ä½¿ç”¨æ‰‹åŠ¨é…ç½®çš„ä»£å¸åœ°å€:', memeTokenAddress);
                }

                // æ£€æŸ¥åˆçº¦çŠ¶æ€ï¼ˆæ˜¯å¦æš‚åœï¼‰
                console.log(LOG_PREFIX, 'å¼€å§‹æ£€æŸ¥åˆçº¦çŠ¶æ€');
                await checkContractStatus();

                // æ›´æ–°UI
                updateAccountDisplay();
                updateNetworkDisplay();
                updateMemeTokenAddressDisplay();
                updateContractStatusDisplay();
                if (domElements.appContent) domElements.appContent.classList.remove('hidden');
                if (domElements.welcomeContent) domElements.welcomeContent.classList.add('hidden');
                if (statusEl) { statusEl.textContent = 'è¿æ¥æˆåŠŸï¼'; statusEl.className = 'status success'; }
                console.log(LOG_PREFIX, 'UIæ›´æ–°å®Œæˆ');

                // åŠ è½½åˆå§‹æ•°æ®
                console.log(LOG_PREFIX, 'å¼€å§‹åŠ è½½åˆå§‹æ•°æ®ï¼ˆåˆ†çº¢+è´¨æŠ¼åˆ—è¡¨ï¼‰');
                await loadPendingRewards();
                await refreshStakes();
                console.log(LOG_PREFIX, 'åˆå§‹æ•°æ®åŠ è½½å®Œæˆ');

            } catch (error) {
                console.error(LOG_PREFIX, 'è¿æ¥å¤±è´¥ï¼Œé”™è¯¯è¯¦æƒ…:', error);
                if (statusEl) { statusEl.textContent = `è¿æ¥å¤±è´¥: ${error.message}`; statusEl.className = 'status error'; }
            } finally {
                // æ¢å¤æŒ‰é’®
                if (connectBtn) { connectBtn.disabled = false; connectBtn.textContent = 'è¿æ¥ MetaMask'; }
                if (welcomeConnectBtn) { welcomeConnectBtn.disabled = false; welcomeConnectBtn.textContent = 'è¿æ¥ MetaMask'; }
                console.log(LOG_PREFIX, '===== è¿æ¥é’±åŒ…é€»è¾‘æ‰§è¡Œç»“æŸ =====');
            }
        }

        // æ£€æŸ¥ç½‘ç»œ
        function checkNetwork() {
            console.log(LOG_PREFIX, 'checkNetworkè°ƒç”¨ï¼Œå½“å‰chainId:', currentChainId);
            const isSupported = currentChainId === BSC_MAINNET_CHAIN_ID;
            if (domElements.networkAlert) {
                domElements.networkAlert.classList.toggle('hidden', isSupported);
            }
            console.log(LOG_PREFIX, 'checkNetworkç»“æœï¼Œæ˜¯å¦æ”¯æŒ:', isSupported);
            return isSupported;
        }

        // æ£€æŸ¥åˆçº¦çŠ¶æ€ï¼ˆæ˜¯å¦æš‚åœï¼‰
        async function checkContractStatus() {
            console.log(LOG_PREFIX, 'checkContractStatusè°ƒç”¨ï¼Œåˆçº¦åœ°å€:', CONTRACT_ADDRESS);
            try {
                const funcData = await encodeFunctionCall('paused', [], 'staking');
                console.log(LOG_PREFIX, 'è°ƒç”¨pausedå‡½æ•°ï¼Œç¼–ç åæ•°æ®:', funcData);

                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: CONTRACT_ADDRESS, data: funcData }, 'latest']
                });
                console.log(LOG_PREFIX, 'åˆçº¦æš‚åœçŠ¶æ€è¿”å›:', result);
                isContractPaused = result === '0x0000000000000000000000000000000000000000000000000000000000000001';
                console.log(LOG_PREFIX, 'åˆçº¦æ˜¯å¦æš‚åœ:', isContractPaused);
            } catch (error) {
                console.error(LOG_PREFIX, 'æ£€æŸ¥åˆçº¦çŠ¶æ€å¤±è´¥:', error);
                isContractPaused = false; // å¤±è´¥é»˜è®¤è§†ä¸ºæœªæš‚åœï¼ˆé¿å…è¯¯åˆ¤ï¼‰
            }
            updateContractStatusDisplay();
        }

        // è·å–ä»£å¸åœ°å€
        async function fetchMemeTokenAddress() {
            console.log(LOG_PREFIX, 'fetchMemeTokenAddressè°ƒç”¨ï¼Œåˆçº¦åœ°å€:', CONTRACT_ADDRESS);
            try {
                const funcData = await encodeFunctionCall('memeToken', [], 'staking');
                console.log(LOG_PREFIX, 'è°ƒç”¨memeTokenå‡½æ•°ï¼Œç¼–ç åæ•°æ®:', funcData);

                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: CONTRACT_ADDRESS, data: funcData }, 'latest']
                });
                console.log(LOG_PREFIX, 'åˆçº¦è°ƒç”¨è¿”å›ç»“æœ:', result);

                memeTokenAddress = `0x${result.slice(-40)}`;
                console.log(LOG_PREFIX, 'è§£æå‡ºä»£å¸åœ°å€:', memeTokenAddress);

                if (memeTokenAddress.length !== 42) throw new Error('è·å–çš„ä»£å¸åœ°å€æ— æ•ˆ');
            } catch (error) {
                console.error(LOG_PREFIX, 'åˆçº¦è°ƒç”¨è·å–ä»£å¸åœ°å€å¤±è´¥:', error);
                const manualInput = prompt('è·å–ä»£å¸åœ°å€å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥MEMEä»£å¸åœ°å€ï¼ˆæ ¼å¼ï¼š0x...ï¼‰:', '');
                if (manualInput && manualInput.length === 42) {
                    memeTokenAddress = manualInput;
                    console.log(LOG_PREFIX, 'ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥ä»£å¸åœ°å€:', memeTokenAddress);
                } else {
                    throw new Error('æ— æ³•è·å–ä»£å¸åœ°å€ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥æ­£ç¡®åœ°å€');
                }
            }
        }

        // åŠ è½½å¯é¢†å–åˆ†çº¢
        async function loadPendingRewards() {
            console.log(LOG_PREFIX, 'loadPendingRewardsè°ƒç”¨ï¼Œè´¦æˆ·:', currentAccount);
            const { pendingRewardsEl, statusEl } = domElements;
            try {
                if (!checkNetwork()) throw new Error('ç½‘ç»œä¸æ”¯æŒ');
                if (!currentAccount) throw new Error('æœªè¿æ¥è´¦æˆ·');
                if (isContractPaused) throw new Error('åˆçº¦å·²æš‚åœï¼Œæ— æ³•æ“ä½œ');

                const funcData = await encodeFunctionCall('getPendingRewards', [currentAccount], 'staking');
                console.log(LOG_PREFIX, 'è°ƒç”¨getPendingRewardså‡½æ•°ï¼Œç¼–ç åæ•°æ®:', funcData);

                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: CONTRACT_ADDRESS, data: funcData }, 'latest']
                });
                console.log(LOG_PREFIX, 'getPendingRewardsè¿”å›ç»“æœ:', result);

                const rewards = formatEther(result);
                if (pendingRewardsEl) pendingRewardsEl.textContent = rewards;
                console.log(LOG_PREFIX, 'å¯é¢†å–åˆ†çº¢æ›´æ–°ä¸º:', rewards);
            } catch (error) {
                console.error(LOG_PREFIX, 'åŠ è½½åˆ†çº¢å¤±è´¥:', error);
                if (pendingRewardsEl) pendingRewardsEl.textContent = 'è·å–å¤±è´¥';
                if (statusEl) { statusEl.textContent = `è·å–åˆ†çº¢å¤±è´¥: ${error.message}`; statusEl.className = 'status error'; }
            }
        }

        // åˆ·æ–°è´¨æŠ¼åˆ—è¡¨
        async function refreshStakes() {
            console.log(LOG_PREFIX, 'refreshStakesè°ƒç”¨ï¼Œè´¦æˆ·:', currentAccount);
            const { stakesListEl, statusEl } = domElements;
            try {
                if (!checkNetwork()) throw new Error('ç½‘ç»œä¸æ”¯æŒ');
                if (!currentAccount) throw new Error('æœªè¿æ¥è´¦æˆ·');
                if (isContractPaused) throw new Error('åˆçº¦å·²æš‚åœï¼Œæ— æ³•æ“ä½œ');
                if (statusEl) { statusEl.textContent = 'æ­£åœ¨åˆ·æ–°è´¨æŠ¼åˆ—è¡¨...'; statusEl.className = 'status info'; }

                // è·å–è´¨æŠ¼æ•°é‡
                const countData = await encodeFunctionCall('getUserStakeCount', [currentAccount], 'staking');
                console.log(LOG_PREFIX, 'è°ƒç”¨getUserStakeCountå‡½æ•°ï¼Œç¼–ç åæ•°æ®:', countData);

                const countResult = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: CONTRACT_ADDRESS, data: countData }, 'latest']
                });
                const stakeCount = parseInt(countResult, 16);
                console.log(LOG_PREFIX, 'è´¨æŠ¼æ•°é‡:', stakeCount);

                if (stakeCount === 0) {
                    if (stakesListEl) stakesListEl.innerHTML = '<div style="text-align: center; color: #666;">æš‚æ— è´¨æŠ¼è®°å½•</div>';
                    if (statusEl) { statusEl.textContent = 'è´¨æŠ¼åˆ—è¡¨å·²åˆ·æ–°'; statusEl.className = 'status success'; }
                    return;
                }

                // éå†è´¨æŠ¼è®°å½•
                if (stakesListEl) stakesListEl.innerHTML = '';
                for (let i = 0; i < stakeCount; i++) {
                    console.log(LOG_PREFIX, 'è·å–ç¬¬', i, 'æ¡è´¨æŠ¼è®°å½•');
                    const stakeData = await encodeFunctionCall('getUserStake', [currentAccount, i], 'staking');
                    const stakeResult = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{ to: CONTRACT_ADDRESS, data: stakeData }, 'latest']
                    });
                    console.log(LOG_PREFIX, 'ç¬¬', i, 'æ¡è´¨æŠ¼è®°å½•è¿”å›:', stakeResult);

                    // è§£ææ•°æ®
                    const amount = formatEther(`0x${stakeResult.slice(2, 66)}`);
                    const startBlock = parseInt(`0x${stakeResult.slice(66, 130)}`, 16);
                    const unlockBlock = parseInt(`0x${stakeResult.slice(130, 194)}`, 16);

                    // åˆ›å»ºDOMå…ƒç´ 
                    const stakeItem = document.createElement('div');
                    stakeItem.className = 'stake-item';
                    stakeItem.innerHTML = `
                        <div class="stake-info">ç´¢å¼•: ${i}</div>
                        <div class="stake-info">æ•°é‡: ${amount} MEME</div>
                        <div class="stake-info">å¼€å§‹åŒºå—: ${startBlock}</div>
                        <div class="stake-info">è§£é”åŒºå—: ${unlockBlock}</div>
                    `;
                    if (stakesListEl) stakesListEl.appendChild(stakeItem);
                }

                if (statusEl) { statusEl.textContent = 'è´¨æŠ¼åˆ—è¡¨å·²åˆ·æ–°'; statusEl.className = 'status success'; }
            } catch (error) {
                console.error(LOG_PREFIX, 'åˆ·æ–°è´¨æŠ¼åˆ—è¡¨å¤±è´¥:', error);
                if (stakesListEl) stakesListEl.innerHTML = '<div style="text-align: center; color: #e74c3c;">åˆ·æ–°å¤±è´¥ï¼Œè¯·é‡è¯•</div>';
                if (statusEl) { statusEl.textContent = `åˆ·æ–°å¤±è´¥: ${error.message}`; statusEl.className = 'status error'; }
            }
        }

        // é¢†å–åˆ†çº¢
        async function claimRewards() {
            console.log(LOG_PREFIX, 'claimRewardsè°ƒç”¨ï¼Œè´¦æˆ·:', currentAccount);
            const { statusEl } = domElements;
            try {
                if (!checkNetwork()) throw new Error('ç½‘ç»œä¸æ”¯æŒ');
                if (!currentAccount) throw new Error('æœªè¿æ¥è´¦æˆ·');
                if (isContractPaused) throw new Error('åˆçº¦å·²æš‚åœï¼Œæ— æ³•é¢†å–');
                if (statusEl) { statusEl.textContent = 'æ­£åœ¨é¢†å–åˆ†çº¢...'; statusEl.className = 'status info'; }

                const funcData = await encodeFunctionCall('claimRewards', [], 'staking');
                console.log(LOG_PREFIX, 'è°ƒç”¨claimRewardså‡½æ•°ï¼Œç¼–ç åæ•°æ®:', funcData);

                // å‘èµ·äº¤æ˜“ï¼ˆæ·»åŠ gasLimitå‚æ•°ï¼Œé¿å…gasä¸è¶³ï¼‰
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: funcData,
                        from: currentAccount,
                        gasLimit: '0x500000' // å¢åŠ gasé™åˆ¶ï¼Œé¿å…æ‰§è¡Œå¤±è´¥
                    }]
                });
                console.log(LOG_PREFIX, 'åˆ†çº¢äº¤æ˜“å·²å‘é€ï¼Œå“ˆå¸Œ:', txHash);

                if (statusEl) { statusEl.textContent = `åˆ†çº¢äº¤æ˜“å·²å‘é€: ${txHash}ï¼ˆå¯åœ¨BscScanæŸ¥è¯¢ï¼‰`; statusEl.className = 'status success'; }

                // ç­‰å¾…ç¡®è®¤ååˆ·æ–°
                setTimeout(async () => {
                    console.log(LOG_PREFIX, 'åˆ†çº¢äº¤æ˜“ç­‰å¾…ç¡®è®¤ååˆ·æ–°æ•°æ®');
                    await loadPendingRewards();
                }, 8000);
            } catch (error) {
                console.error(LOG_PREFIX, 'é¢†å–åˆ†çº¢å¤±è´¥:', error);
                // å¸¸è§é”™è¯¯æç¤ºä¼˜åŒ–
                let errorMsg = error.message;
                if (errorMsg.includes('no transaction hash')) {
                    errorMsg = 'äº¤æ˜“æ— å“ˆå¸Œï¼šå¯èƒ½æ˜¯åˆçº¦æ— è¶³å¤ŸBNBåˆ†çº¢ã€gasä¸è¶³æˆ–åˆçº¦æ‰§è¡Œå¤±è´¥';
                }
                if (statusEl) { statusEl.textContent = `é¢†å–å¤±è´¥: ${errorMsg}`; statusEl.className = 'status error'; }
            }
        }

        // æˆæƒä»£å¸ï¼ˆå…³é”®ä¿®å¤ï¼šä½¿ç”¨ERC20 ABIï¼‰
        async function approveToken() {
            console.log(LOG_PREFIX, 'approveTokenè°ƒç”¨');
            const { stakeAmountInput, statusEl } = domElements;
            try {
                if (!checkNetwork()) throw new Error('ç½‘ç»œä¸æ”¯æŒ');
                if (!currentAccount) throw new Error('æœªè¿æ¥è´¦æˆ·');
                if (!memeTokenAddress) throw new Error('æœªè·å–åˆ°ä»£å¸åœ°å€');
                if (isContractPaused) throw new Error('åˆçº¦å·²æš‚åœï¼Œæ— æ³•æˆæƒ');

                const amount = stakeAmountInput.value.trim();
                console.log(LOG_PREFIX, 'æˆæƒæ•°é‡:', amount);
                if (!amount || parseFloat(amount) <= 0) throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„è´¨æŠ¼æ•°é‡');

                if (statusEl) { statusEl.textContent = 'æ­£åœ¨æˆæƒä»£å¸...'; statusEl.className = 'status info'; }

                // å…³é”®ä¿®å¤ï¼šä½¿ç”¨ERC20 ABIç¼–ç approveå‡½æ•°
                const funcData = await encodeFunctionCall('approve', [CONTRACT_ADDRESS, parseEther(amount)], 'erc20');
                console.log(LOG_PREFIX, 'è°ƒç”¨ERC20 approveå‡½æ•°ï¼Œç¼–ç åæ•°æ®:', funcData);

                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: memeTokenAddress, // æˆæƒç›®æ ‡æ˜¯MEMEä»£å¸åˆçº¦ï¼Œä¸æ˜¯è´¨æŠ¼åˆçº¦ï¼
                        data: funcData,
                        from: currentAccount,
                        gasLimit: '0x300000'
                    }]
                });
                console.log(LOG_PREFIX, 'æˆæƒäº¤æ˜“å·²å‘é€ï¼Œå“ˆå¸Œ:', txHash);

                if (statusEl) { statusEl.textContent = `æˆæƒäº¤æ˜“å·²å‘é€: ${txHash}ï¼ˆå¯åœ¨BscScanæŸ¥è¯¢ï¼‰`; statusEl.className = 'status success'; }
            } catch (error) {
                console.error(LOG_PREFIX, 'æˆæƒä»£å¸å¤±è´¥:', error);
                if (statusEl) { statusEl.textContent = `æˆæƒå¤±è´¥: ${error.message}`; statusEl.className = 'status error'; }
            }
        }

        // è´¨æŠ¼ä»£å¸
        async function stakeToken() {
            console.log(LOG_PREFIX, 'stakeTokenè°ƒç”¨');
            const { stakeAmountInput, statusEl } = domElements;
            try {
                if (!checkNetwork()) throw new Error('ç½‘ç»œä¸æ”¯æŒ');
                if (!currentAccount) throw new Error('æœªè¿æ¥è´¦æˆ·');
                if (isContractPaused) throw new Error('åˆçº¦å·²æš‚åœï¼Œæ— æ³•è´¨æŠ¼');

                const amount = stakeAmountInput.value.trim();
                console.log(LOG_PREFIX, 'è´¨æŠ¼æ•°é‡:', amount);
                if (!amount || parseFloat(amount) <= 0) throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„è´¨æŠ¼æ•°é‡');

                if (statusEl) { statusEl.textContent = 'æ­£åœ¨è´¨æŠ¼ä»£å¸...'; statusEl.className = 'status info'; }

                const funcData = await encodeFunctionCall('stake', [parseEther(amount)], 'staking');
                console.log(LOG_PREFIX, 'è°ƒç”¨stakeå‡½æ•°ï¼Œç¼–ç åæ•°æ®:', funcData);

                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: funcData,
                        from: currentAccount,
                        gasLimit: '0x500000'
                    }]
                });
                console.log(LOG_PREFIX, 'è´¨æŠ¼äº¤æ˜“å·²å‘é€ï¼Œå“ˆå¸Œ:', txHash);

                if (statusEl) { statusEl.textContent = `è´¨æŠ¼äº¤æ˜“å·²å‘é€: ${txHash}ï¼ˆå¯åœ¨BscScanæŸ¥è¯¢ï¼‰`; statusEl.className = 'status success'; }

                // ç­‰å¾…ç¡®è®¤ååˆ·æ–°
                setTimeout(async () => {
                    console.log(LOG_PREFIX, 'è´¨æŠ¼äº¤æ˜“ç­‰å¾…ç¡®è®¤ååˆ·æ–°æ•°æ®');
                    await refreshStakes();
                    await loadPendingRewards();
                    if (stakeAmountInput) stakeAmountInput.value = '';
                }, 8000);
            } catch (error) {
                console.error(LOG_PREFIX, 'è´¨æŠ¼ä»£å¸å¤±è´¥:', error);
                if (statusEl) { statusEl.textContent = `è´¨æŠ¼å¤±è´¥: ${error.message}`; statusEl.className = 'status error'; }
            }
        }

        // å–æ¶ˆè´¨æŠ¼
        async function unstakeToken() {
            console.log(LOG_PREFIX, 'unstakeTokenè°ƒç”¨');
            const { unstakeIndexInput, statusEl } = domElements;
            try {
                if (!checkNetwork()) throw new Error('ç½‘ç»œä¸æ”¯æŒ');
                if (!currentAccount) throw new Error('æœªè¿æ¥è´¦æˆ·');
                if (isContractPaused) throw new Error('åˆçº¦å·²æš‚åœï¼Œæ— æ³•å–æ¶ˆè´¨æŠ¼');

                const index = parseInt(unstakeIndexInput.value.trim());
                console.log(LOG_PREFIX, 'å–æ¶ˆè´¨æŠ¼ç´¢å¼•:', index);
                if (isNaN(index) || index < 0) throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„è´¨æŠ¼ç´¢å¼•');

                if (statusEl) { statusEl.textContent = 'æ­£åœ¨å–æ¶ˆè´¨æŠ¼...'; statusEl.className = 'status info'; }

                const funcData = await encodeFunctionCall('unstake', [index.toString()], 'staking'); // è½¬ä¸ºå­—ç¬¦ä¸²é¿å…BigInté—®é¢˜
                console.log(LOG_PREFIX, 'è°ƒç”¨unstakeå‡½æ•°ï¼Œç¼–ç åæ•°æ®:', funcData);

                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: funcData,
                        from: currentAccount,
                        gasLimit: '0x500000'
                    }]
                });
                console.log(LOG_PREFIX, 'å–æ¶ˆè´¨æŠ¼äº¤æ˜“å·²å‘é€ï¼Œå“ˆå¸Œ:', txHash);

                if (statusEl) { statusEl.textContent = `å–æ¶ˆè´¨æŠ¼äº¤æ˜“å·²å‘é€: ${txHash}ï¼ˆå¯åœ¨BscScanæŸ¥è¯¢ï¼‰`; statusEl.className = 'status success'; }

                // ç­‰å¾…ç¡®è®¤ååˆ·æ–°
                setTimeout(async () => {
                    console.log(LOG_PREFIX, 'å–æ¶ˆè´¨æŠ¼äº¤æ˜“ç­‰å¾…ç¡®è®¤ååˆ·æ–°æ•°æ®');
                    await refreshStakes();
                    await loadPendingRewards();
                    if (unstakeIndexInput) unstakeIndexInput.value = '';
                }, 8000);
            } catch (error) {
                console.error(LOG_PREFIX, 'å–æ¶ˆè´¨æŠ¼å¤±è´¥:', error);
                let errorMsg = error.message;
                if (errorMsg.includes('no transaction hash')) {
                    errorMsg = 'äº¤æ˜“æ— å“ˆå¸Œï¼šå¯èƒ½æ˜¯ç´¢å¼•æ— æ•ˆã€æœªåˆ°è§£é”æ—¶é—´æˆ–åˆçº¦æ‰§è¡Œå¤±è´¥';
                }
                if (statusEl) { statusEl.textContent = `å–æ¶ˆè´¨æŠ¼å¤±è´¥: ${errorMsg}`; statusEl.className = 'status error'; }
            }
        }

        // ==================== UIæ›´æ–°å‡½æ•° ====================
        function updateAccountDisplay() {
            console.log(LOG_PREFIX, 'updateAccountDisplayè°ƒç”¨ï¼Œè´¦æˆ·:', currentAccount);
            if (domElements.connectedAccountEl && currentAccount) {
                domElements.connectedAccountEl.textContent = `${currentAccount.substring(0,6)}...${currentAccount.substring(38)}`;
            }
        }

        function updateNetworkDisplay() {
            console.log(LOG_PREFIX, 'updateNetworkDisplayè°ƒç”¨ï¼ŒchainId:', currentChainId);
            if (domElements.currentNetworkEl && currentChainId) {
                const networkName = currentChainId === BSC_MAINNET_CHAIN_ID ? 'BSCä¸»ç½‘ï¼ˆ56ï¼‰' : `æœªçŸ¥ç½‘ç»œï¼ˆ${currentChainId}ï¼‰`;
                domElements.currentNetworkEl.textContent = networkName;
            }
        }

        function updateMemeTokenAddressDisplay() {
            console.log(LOG_PREFIX, 'updateMemeTokenAddressDisplayè°ƒç”¨ï¼Œåœ°å€:', memeTokenAddress);
            if (domElements.memeTokenAddressEl && memeTokenAddress) {
                domElements.memeTokenAddressEl.textContent = `${memeTokenAddress.substring(0,6)}...${memeTokenAddress.substring(38)}`;
            }
        }

        function updateContractStatusDisplay() {
            console.log(LOG_PREFIX, 'updateContractStatusDisplayè°ƒç”¨ï¼Œæ˜¯å¦æš‚åœ:', isContractPaused);
            if (domElements.contractStatusEl) {
                domElements.contractStatusEl.textContent = isContractPaused ? 'å·²æš‚åœ' : 'æ­£å¸¸';
            }
            if (domElements.contractPausedWarning) {
                domElements.contractPausedWarning.classList.toggle('hidden', !isContractPaused);
            }
            // ç¦ç”¨æ‰€æœ‰æ“ä½œæŒ‰é’®ï¼ˆå¦‚æœåˆçº¦æš‚åœï¼‰
            const actionBtns = [
                domElements.claimRewardsBtn,
                domElements.approveTokenBtn,
                domElements.stakeTokenBtn,
                domElements.unstakeTokenBtn
            ];
            actionBtns.forEach(btn => {
                if (btn) btn.disabled = isContractPaused;
            });
        }
    </script>
</body>
</html>
